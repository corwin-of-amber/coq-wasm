diff --git a/lib/control.ml b/lib/control.ml
index f3ce295..8dd815d 100644
--- a/lib/control.ml
+++ b/lib/control.ml
@@ -18,7 +18,19 @@ let enable_thread_delay = ref false
 
 exception Timeout
 
+(* implemented in core.ts *)
+external interrupt_pending : unit -> bool = "interrupt_pending"
+
+let timeout_deadline : (float * (unit -> unit)) option ref = ref None
+
+let jscoq_event_yield () =
+  if interrupt_pending() then interrupt := true;
+  match !timeout_deadline with
+  | Some (time, callback) -> if Unix.gettimeofday () > time then callback ();
+  | None -> ()
+
 let check_for_interrupt () =
+  jscoq_event_yield ();
   if !interrupt then begin interrupt := false; raise Sys.Break end;
   if !enable_thread_delay then begin
     incr steps;
@@ -98,11 +110,30 @@ let windows_timeout n f x =
     let () = killed := true in
     Exninfo.iraise e
 
+let unwind ~(protect:unit -> unit) f =
+  try let y = f () in protect (); y
+  with e -> protect (); raise e
+
+let jscoq_timeout n f x =
+  let expired = ref false in
+  timeout_deadline := Some (Unix.gettimeofday () +. n,
+                            fun () -> expired := true; interrupt := true);
+  let protect () = jscoq_event_yield (); timeout_deadline := None;
+                   interrupt := false in
+  let res = try Some(unwind ~protect (fun () -> f x))
+            with Sys.Break -> if !expired then None else raise Sys.Break in
+  if !expired then None
+  else res
+
 type timeout = { timeout : 'a 'b. float -> ('a -> 'b) -> 'a -> 'b option }
 
+(*
 let timeout_fun = match Sys.os_type with
 | "Unix" | "Cygwin" -> { timeout = unix_timeout }
 | _ -> { timeout = windows_timeout }
+*)
+let _ = windows_timeout, unix_timeout
+let timeout_fun = { timeout = jscoq_timeout }
 
 let timeout_fun_ref = ref timeout_fun
 let set_timeout f = timeout_fun_ref := f
